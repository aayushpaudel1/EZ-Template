"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9554],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return c}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(a),c=s,_=m["".concat(o,".").concat(c)]||m[c]||d[c]||r;return a?n.createElement(_,i(i({ref:t},u),{},{components:a})):n.createElement(_,i({ref:t},u))}));function c(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,i=new Array(r);i[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:s,i[1]=l;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5162:function(e,t,a){a.d(t,{Z:function(){return i}});var n=a(7294),s=a(6010),r="tabItem_Ymn6";function i(e){var t=e.children,a=e.hidden,i=e.className;return n.createElement("div",{role:"tabpanel",className:(0,s.Z)(r,i),hidden:a},t)}},5488:function(e,t,a){a.d(t,{Z:function(){return c}});var n=a(7462),s=a(7294),r=a(6010),i=a(2389),l=a(7392),o=a(7094),p=a(2466),u="tabList__CuJ",d="tabItem_LNqP";function m(e){var t,a,i=e.lazy,m=e.block,c=e.defaultValue,_=e.values,v=e.groupId,k=e.className,h=s.Children.map(e.children,(function(e){if((0,s.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=_?_:h.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,l.l)(g,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var f=null===c?c:null!=(t=null!=c?c:null==(a=h.find((function(e){return e.props.default})))?void 0:a.props.value)?t:h[0].props.value;if(null!==f&&!g.some((function(e){return e.value===f})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+f+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var x=(0,o.U)(),N=x.tabGroupChoices,T=x.setTabGroupChoices,w=(0,s.useState)(f),y=w[0],I=w[1],E=[],D=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=v){var Z=N[v];null!=Z&&Z!==y&&g.some((function(e){return e.value===Z}))&&I(Z)}var P=function(e){var t=e.currentTarget,a=E.indexOf(t),n=g[a].value;n!==y&&(D(t),I(n),null!=v&&T(v,String(n)))},C=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n,s=E.indexOf(e.currentTarget)+1;a=null!=(n=E[s])?n:E[0];break;case"ArrowLeft":var r,i=E.indexOf(e.currentTarget)-1;a=null!=(r=E[i])?r:E[E.length-1]}null==(t=a)||t.focus()};return s.createElement("div",{className:(0,r.Z)("tabs-container",u)},s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":m},k)},g.map((function(e){var t=e.value,a=e.label,i=e.attributes;return s.createElement("li",(0,n.Z)({role:"tab",tabIndex:y===t?0:-1,"aria-selected":y===t,key:t,ref:function(e){return E.push(e)},onKeyDown:C,onFocus:P,onClick:P},i,{className:(0,r.Z)("tabs__item",d,null==i?void 0:i.className,{"tabs__item--active":y===t})}),null!=a?a:t)}))),i?(0,s.cloneElement)(h.filter((function(e){return e.props.value===y}))[0],{className:"margin-top--md"}):s.createElement("div",{className:"margin-top--md"},h.map((function(e,t){return(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==y})}))))}function c(e){var t=(0,i.Z)();return s.createElement(m,(0,n.Z)({key:String(t)},e))}},4627:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return u},default:function(){return v},frontMatter:function(){return p},metadata:function(){return d},toc:function(){return c}});var n=a(7462),s=a(3366),r=(a(7294),a(3905)),i=a(5488),l=a(5162),o=["components"],p={layout:"default",title:"Autonomous Functions",parent:"Docs",nav_order:4},u="**Autonomous Functions**",d={unversionedId:"Docs/auton_functions",id:"Docs/auton_functions",title:"Autonomous Functions",description:"Assumed Constructor",source:"@site/docs/Docs/auton_functions.md",sourceDirName:"Docs",slug:"/Docs/auton_functions",permalink:"/EZ-Template/Docs/auton_functions",draft:!1,tags:[],version:"current",frontMatter:{layout:"default",title:"Autonomous Functions",parent:"Docs",nav_order:4},sidebar:"tutorialSidebar",previous:{title:"Docs",permalink:"/EZ-Template/category/docs"},next:{title:"Autonomous Selector",permalink:"/EZ-Template/Docs/auton_selector"}},m={},c=[{value:"Assumed Constructor",id:"assumed-constructor",level:2},{value:"Setter functions",id:"setter-functions",level:2},{value:"set_drive_pid()",id:"set_drive_pid",level:3},{value:"set_turn_pid()",id:"set_turn_pid",level:3},{value:"set_swing_pid()",id:"set_swing_pid",level:3},{value:"reset_pid_targets()",id:"reset_pid_targets",level:3},{value:"set_angle()",id:"set_angle",level:3},{value:"set_max_speed()",id:"set_max_speed",level:3},{value:"set_pid_constants()",id:"set_pid_constants",level:3},{value:"set_slew_min_power()",id:"set_slew_min_power",level:3},{value:"set_slew_distance()",id:"set_slew_distance",level:3},{value:"set_exit_condition()",id:"set_exit_condition",level:3},{value:"set_swing_min()",id:"set_swing_min",level:3},{value:"set_turn_min()",id:"set_turn_min",level:3},{value:"set_mode()",id:"set_mode",level:3},{value:"toggle_auto_drive()",id:"toggle_auto_drive",level:3},{value:"toggle_auto_print()",id:"toggle_auto_print",level:3},{value:"Getter",id:"getter",level:2},{value:"get_swing_min()",id:"get_swing_min",level:3},{value:"get_turn_min()",id:"get_turn_min",level:3},{value:"interfered",id:"interfered",level:3},{value:"get_mode()",id:"get_mode",level:3},{value:"get_tick_per_inch()",id:"get_tick_per_inch",level:3},{value:"Misc.",id:"misc",level:2},{value:"wait_drive()",id:"wait_drive",level:3},{value:"wait_until()",id:"wait_until",level:3}],_={toc:c};function v(e){var t=e.components,a=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,n.Z)({},_,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"autonomous-functions"},(0,r.kt)("strong",{parentName:"h1"},"Autonomous Functions")),(0,r.kt)("h2",{id:"assumed-constructor"},"Assumed Constructor"),(0,r.kt)("p",null,"All code below assumes this constructor is used.  As long as the name of the constructor is ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis"),", any of the constructors can be used. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Chassis constructor\nDrive chassis (\n  // Left Chassis Ports (negative port will reverse it!)\n  //   the first port is the sensored port (when trackers are not used!)\n  {1, -2, 3}\n\n  // Right Chassis Ports (negative port will reverse it!)\n  //   the first port is the sensored port (when trackers are not used!)\n  ,{-4, 5, -6}\n\n  // IMU Port\n  ,7\n\n  // Wheel Diameter (Remember, 4" wheels are actually 4.125!)\n  //    (or tracking wheel diameter)\n  ,4.125\n\n  // Cartridge RPM\n  //   (or tick per rotation if using tracking wheels)\n  ,600\n\n  // External Gear Ratio (MUST BE DECIMAL)\n  //    (or gear ratio of tracking wheel)\n  // eg. if your drive is 84:36 where the 36t is powered, your RATIO would be 2.333.\n  // eg. if your drive is 36:60 where the 60t is powered, your RATIO would be 0.6.\n  ,2.333\n\n  // Uncomment if using tracking wheels\n  /*\n  // Left Tracking Wheel Ports (negative port will reverse it!)\n  ,{1, 2}\n\n  // Right Tracking Wheel Ports (negative port will reverse it!)\n  ,{3, 4}\n  */\n\n  // Uncomment if tracking wheels are plugged into a 3 wire expander\n  // 3 Wire Port Expander Smart Port\n  // ,9\n);\n\n')),(0,r.kt)("h2",{id:"setter-functions"},"Setter functions"),(0,r.kt)("h3",{id:"set_drive_pid"},"set_drive_pid()"),(0,r.kt)("p",null,"Sets the drive to go forward using PID and heading correction.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"target")," is in inches.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," is -127 to 127.  It's recommended to keep this at 110.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"slew_on")," will ramp the drive up.\n",(0,r.kt)("inlineCode",{parentName:"p"},"toggle_heading")," will disable heading correction when false. "),(0,r.kt)(i.Z,{groupId:"examples1",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_drive_pid(24, 110, true);\n  chassis.wait_drive();\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_drive_pid(double target, int speed, bool slew_on = false, bool toggle_heading = true);\n")))),(0,r.kt)("h3",{id:"set_turn_pid"},"set_turn_pid()"),(0,r.kt)("p",null,"Sets the drive to turn using PID.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"target")," is in degrees.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," is -127 to 127.    "),(0,r.kt)(i.Z,{groupId:"examples2",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_drive_pid(24, 110, true);\n  chassis.wait_drive();\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_turn_pid(double target, int speed);\n")))),(0,r.kt)("h3",{id:"set_swing_pid"},"set_swing_pid()"),(0,r.kt)("p",null,"Sets the robot to swing using PID.  The robot will turn using one side of the drive, either the left or right.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"type")," is either ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::LEFT_SWING")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::RIGHT_SWING"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"target")," is in degrees.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," is -127 to 127.        "),(0,r.kt)(i.Z,{groupId:"examples3",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_swing_pid(e_swing type, double target, int speed);\n"))),(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_swing_pid(ez::LEFT_SWING, 45, 110);\n  chassis.wait_drive();\n\n  chassis.set_swing_pid(ez::RIGHT_SWING, 0, 110);\n  chassis.wait_drive();\n}\n")))),(0,r.kt)("h3",{id:"reset_pid_targets"},"reset_pid_targets()"),(0,r.kt)("p",null,"Resets all drive PID targets to 0.       "),(0,r.kt)(i.Z,{groupId:"examples4",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_pid_targets(); // Resets PID targets to 0\n  chassis.reset_gyro(); // Reset gyro position to 0\n  chassis.reset_drive_sensor(); // Reset drive sensors to 0\n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); // Set motors to hold.  This helps autonomous consistency.\n\n  ez::as::auton_selector.call_selected_auton(); // Calls selected auton from autonomous selector.\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void reset_pid_targets();\n")))),(0,r.kt)("h3",{id:"set_angle"},"set_angle()"),(0,r.kt)("p",null,"Sets the angle of the robot.  This is useful when your robot is setup in at an unconventional angle and you want 0 to be when you're square with the field.         "),(0,r.kt)(i.Z,{groupId:"examples5",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_angle(double angle);\n"))),(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_pid_targets(); // Resets PID targets to 0\n  chassis.reset_gyro(); // Reset gyro position to 0\n  chassis.reset_drive_sensor(); // Reset drive sensors to 0\n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); // Set motors to hold.  This helps autonomous consistency.\n\n  chassis.set_angle(45);\n\n  chassis.set_turn_pid(0, TURN_SPEED);\n  chassis.wait_drive();\n}\n")))),(0,r.kt)("h3",{id:"set_max_speed"},"set_max_speed()"),(0,r.kt)("p",null,"Sets the max speed of the drive.\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," an integer between -127 and 127.     "),(0,r.kt)(i.Z,{groupId:"examples6",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_drive_pid(48, 110);\n  chassis.wait_until(24);\n  chassis.set_max_speed(40);\n  chassis.wait_drive();\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_max_speed(int speed);\n")))),(0,r.kt)("h3",{id:"set_pid_constants"},"set_pid_constants()"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note: this function was changed with 2.0.1"),(0,r.kt)("br",{parentName:"p"}),"\n","Set PID constants.  Below are the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"pid")," either ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.headingPID"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.forward_drivePID"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.backward_drivePID"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.turnPID"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.swingPID"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p")," proportion constant.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"i")," integral constant.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"d")," derivative constant.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_start_i")," error needs to be within this for i to start.      "),(0,r.kt)(i.Z,{groupId:"examples7",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_pid_constants(&chassis.headingPID, 11, 0, 20, 0);\n  chassis.set_pid_constants(&chassis.forward_drivePID, 0.45, 0, 5, 0);\n  chassis.set_pid_constants(&chassis.backward_drivePID, 0.45, 0, 5, 0);\n  chassis.set_pid_constants(&chassis.turnPID, 5, 0.003, 35, 15;\n  chassis.set_pid_constants(&chassis.swingPID, 7, 0, 45, 0);\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_pid_constants(PID* pid, double p, double i, double d, double p_start_i);\n")))),(0,r.kt)("h3",{id:"set_slew_min_power"},"set_slew_min_power()"),(0,r.kt)("p",null,"Sets the starting speed for slew, with the ability to have different constants for forward and reverse.  Below is the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"fwd")," integer between -127 and 127.\n",(0,r.kt)("inlineCode",{parentName:"p"},"rev")," integer between -127 and 127.  "),(0,r.kt)(i.Z,{groupId:"examples8",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_slew_min_power(80, 80);\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_slew_min_power(int fwd, int rev);\n")))),(0,r.kt)("h3",{id:"set_slew_distance"},"set_slew_distance()"),(0,r.kt)("p",null,"Sets the distance the drive will slew for, with the ability to have different constants for forward and reverse.  Input is inches.  Below is the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"fwd")," a distance in inches.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"rev")," a distance in inches.   "),(0,r.kt)(i.Z,{groupId:"examples9",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_slew_min_distance(7, 7);\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_slew_distance (int fwd, int rev);\n")))),(0,r.kt)("h3",{id:"set_exit_condition"},"set_exit_condition()"),(0,r.kt)("p",null,"Sets the exit condition constants. This uses the exit conditions from the PID class.  Below is the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"type")," either ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis.turn_exit"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis.swing_exit"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis.drive_exit"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_small_exit_time")," time, in ms, before exiting ",(0,r.kt)("inlineCode",{parentName:"p"},"p_small_error"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_small_error")," small error threshold",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_big_exit_time")," time, in ms, before exiting ",(0,r.kt)("inlineCode",{parentName:"p"},"p_big_error"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_big_error")," big error threshold",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_velocity_exit_time")," time, in ms, for velocity to be 0",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_mA_timeout")," time, in ms, for ",(0,r.kt)("inlineCode",{parentName:"p"},"is_over_current")," to be true       "),(0,r.kt)(i.Z,{groupId:"examples10",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_exit_condition(chassis.turn_exit,  100, 3,  500, 7,   500, 500);\n  chassis.set_exit_condition(chassis.swing_exit, 100, 3,  500, 7,   500, 500);\n  chassis.set_exit_condition(chassis.drive_exit, 80,  50, 300, 150, 500, 500);\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_exit_condition(exit_condition_ &type, int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout);\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("h3",{id:"set_swing_min"},"set_swing_min()"),(0,r.kt)("p",null,"Sets the max power of the drive when the robot is within ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".  This only enalbes when ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is enabled, and when the movement is greater then ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".        "),(0,r.kt)(i.Z,{groupId:"examples11",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_swing_min(30);\n\n  chassis.set_swing_pid(45, 110);\n  chassis.wait_drive();\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_swing_min(int min);\n")))),(0,r.kt)("h3",{id:"set_turn_min"},"set_turn_min()"),(0,r.kt)("p",null,"Sets the max power of the drive when the robot is within ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".  This only enalbes when ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is enabled, and when the movement is greater then ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".        "),(0,r.kt)(i.Z,{groupId:"examples12",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_turn_min(30);\n\n  chassis.set_turn_pid(45, 110);\n  chassis.wait_drive();\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_turn_min(int min);\n")))),(0,r.kt)("h3",{id:"set_mode"},"set_mode()"),(0,r.kt)("p",null,"Sets the current mode of the drive.  Accepts ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DISABLE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::SWING"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::TURN"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DRIVE"),".           "),(0,r.kt)(i.Z,{groupId:"examples13",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED);\n  chassis.wait_drive();\n\n  chassis.set_mode(ez::DISABLE); // Disable drive\n\n  chassis.set_tank(-127, -127); // Run drive motors myself\n  pros::delay(2000);\n  chassis.set_tank(0, 0);\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_mode(e_mode p_mode);\n")))),(0,r.kt)("h3",{id:"toggle_auto_drive"},"toggle_auto_drive()"),(0,r.kt)("p",null,"Enables/disables the drive from moving in autonomous.  This is useful for debugging and checking PID variables.  True enables, false disables.         "),(0,r.kt)(i.Z,{groupId:"examples14",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED);\n  chassis.wait_drive();\n\n  toggle_auto_drive(false); // Disable drive\n\n  chassis.set_drive_pid(-12, DRIVE_SPEED);\n  while (true) {\n    printf(" Left Error: %f  Right Error: %f\\n", chassis.leftPID.error, chassis.rightPID.error);\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n'))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void toggle_auto_drive(bool toggle);\n")))),(0,r.kt)("h3",{id:"toggle_auto_print"},"toggle_auto_print()"),(0,r.kt)("p",null,"Enables/disables the drive functions printing every drive motion.  This is useful when you're debugging something and don't want terminal cluttered.  True enables, false disables.          "),(0,r.kt)(i.Z,{groupId:"examples15",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED); // This will print\n  chassis.wait_drive(); // This will print\n\n  toggle_auto_print(false); // Disable prints\n\n  chassis.set_drive_pid(-12, DRIVE_SPEED); // This won't print\n  chassis.wait_drive(); // This won't print\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void toggle_auto_print(bool toggle);\n")))),(0,r.kt)("h2",{id:"getter"},"Getter"),(0,r.kt)("h3",{id:"get_swing_min"},"get_swing_min()"),(0,r.kt)("p",null,"Returns swing min.         "),(0,r.kt)(i.Z,{groupId:"examples16",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void autonomous() {\n  chassis.set_swing_min(30);\n\n  printf("Swing Min: %i", chassis.get_swing_min());\n}\n'))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int get_swing_min();\n")))),(0,r.kt)("h3",{id:"get_turn_min"},"get_turn_min()"),(0,r.kt)("p",null,"Returns turn min.         "),(0,r.kt)(i.Z,{groupId:"examples17",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void autonomous() {\n  chassis.set_turn_min(30);\n\n  printf("Turn Min: %i", chassis.get_turn_min());\n}\n'))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int get_turn_min();\n")))),(0,r.kt)("h3",{id:"interfered"},"interfered"),(0,r.kt)("p",null,"Boolean that returns true when ",(0,r.kt)("inlineCode",{parentName:"p"},"wait_drive()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"wait_until()")," exit with velocity or is_over_current.      "),(0,r.kt)(i.Z,{groupId:"examples18",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' void tug (int attempts) {\n   for (int i=0; i<attempts-1; i++) {\n     // Attempt to drive backwards\n     printf("i - %i", i);\n     chassis.set_drive_pid(-12, 127);\n     chassis.wait_drive();\n\n     // If failsafed...\n     if (chassis.interfered) {\n       chassis.reset_drive_sensor();\n       chassis.set_drive_pid(-2, 20);\n       pros::delay(1000);\n     }\n     // If robot successfully drove back, return\n     else {\n       return;\n     }\n   }\n }\n\nvoid auto1() {\n  chassis.set_drive_pid(24, 110, true);\n  chassis.wait_drive();\n\n  if (chassis.interfered) {\n    tug(3);\n    return;\n  }\n\n  chassis.set_turn_pid(90, 90);\n  chassis.wait_drive();\n}\n'))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool interfered = false;\n")))),(0,r.kt)("h3",{id:"get_mode"},"get_mode()"),(0,r.kt)("p",null,"Returns the current drive mode.  Returns ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DISABLE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::SWING"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::TURN"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DRIVE"),".           "),(0,r.kt)(i.Z,{groupId:"examples19",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED);\n  chassis.wait_drive();\n\n  if (chassis.interfered)\n    chassis.set_mode(ez::DISABLE);\n  \n  if (chassis.get_mode() == ez::DISABLE) {\n    chassis.set_tank(-127, -127); // Run drive motors myself\n    pros::delay(2000);\n    chassis.set_tank(0, 0);\n  }\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"e_mode get_mode();\n")))),(0,r.kt)("h3",{id:"get_tick_per_inch"},"get_tick_per_inch()"),(0,r.kt)("p",null,"Returns current tick per inch.           "),(0,r.kt)(i.Z,{groupId:"examples20",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void initialize() {\n  printf("Tick Per Inch: %f\\n", chassis.get_tick_per_inch());\n}\n'))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"double get_tick_per_inch();\n")))),(0,r.kt)("h2",{id:"misc"},"Misc."),(0,r.kt)("h3",{id:"wait_drive"},"wait_drive()"),(0,r.kt)("p",null,"Locks the code in place until the drive has settled.  This uses the exit conditions from the PID class.      "),(0,r.kt)(i.Z,{groupId:"examples21",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_turn_pid(90, 110);\n  chassis.wait_drive();\n\n  chassis.set_turn_pid(0, 110);\n  chassis.wait_drive();\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void wait_drive();\n")))),(0,r.kt)("h3",{id:"wait_until"},"wait_until()"),(0,r.kt)("p",null,"Locks the code in place until the drive has passed the input parameter.  This uses the exit conditions from the PID class.           "),(0,r.kt)(i.Z,{groupId:"examples22",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"example",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_drive_pid(48, 110);\n  chassis.wait_until(24);\n  chassis.set_max_speed(40);\n  chassis.wait_drive();\n}\n"))),(0,r.kt)(l.Z,{value:"proto",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void wait_until(double target);\n")))))}v.isMDXComponent=!0}}]);